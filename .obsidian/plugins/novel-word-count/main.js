/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => NovelWordCountPlugin
});

// logic/debug.ts
var DebugHelper = class {
  constructor() {
    this.debugMode = false;
  }
  setDebugMode(debug) {
    this.debugMode = debug;
  }
  debug(...args) {
    if (!this.debugMode) {
      return;
    }
    console.log("novel-word-count:", ...args);
  }
  debugStart(name) {
    if (!this.debugMode) {
      return () => {
      };
    }
    var qualifiedName = `novel-word-count|${name}`;
    console.time(qualifiedName);
    return () => console.timeEnd(qualifiedName);
  }
};

// logic/file.ts
var import_obsidian = __toModule(require("obsidian"));
var FileHelper = class {
  constructor(vault) {
    this.vault = vault;
    this.debugHelper = new DebugHelper();
  }
  getAllFileCounts() {
    return __async(this, null, function* () {
      const debugEnd = this.debugHelper.debugStart("getAllFileCounts");
      const files = this.vault.getMarkdownFiles();
      const counts = {};
      for (const file of files) {
        const contents = yield this.vault.cachedRead(file);
        const wordCount = this.countWords(contents);
        this.setCounts(counts, file, wordCount, contents);
      }
      debugEnd();
      return counts;
    });
  }
  getCountDataForPath(counts, path) {
    if (counts.hasOwnProperty(path)) {
      return counts[path];
    }
    const childPaths = Object.keys(counts).filter((countPath) => path === "/" || countPath.startsWith(path + "/"));
    return childPaths.reduce((total, childPath) => {
      const childCount = this.getCountDataForPath(counts, childPath);
      total.wordCount += childCount.wordCount;
      total.pageCount += childCount.pageCount;
      total.characterCount += childCount.characterCount;
      total.createdDate = total.createdDate === 0 ? childCount.createdDate : Math.min(total.createdDate, childCount.createdDate);
      total.modifiedDate = Math.max(total.modifiedDate, childCount.modifiedDate);
      return total;
    }, {
      wordCount: 0,
      pageCount: 0,
      characterCount: 0,
      createdDate: 0,
      modifiedDate: 0
    });
  }
  setDebugMode(debug) {
    this.debugHelper.setDebugMode(debug);
  }
  updateFileCounts(abstractFile, counts) {
    return __async(this, null, function* () {
      if (abstractFile instanceof import_obsidian.TFolder) {
        this.debugHelper.debug("updateFileCounts called on instance of TFolder");
        Object.assign(counts, this.getAllFileCounts());
        return;
      }
      if (abstractFile instanceof import_obsidian.TFile) {
        const contents = yield this.vault.cachedRead(abstractFile);
        const wordCount = this.countWords(contents);
        this.setCounts(counts, abstractFile, wordCount, contents);
      }
    });
  }
  countWords(content) {
    return (content.match(/[^\s]+/g) || []).length;
  }
  setCounts(counts, file, wordCount, content) {
    counts[file.path] = {
      wordCount,
      pageCount: Math.ceil(wordCount / 300),
      characterCount: content.length,
      createdDate: file.stat.ctime,
      modifiedDate: file.stat.mtime
    };
  }
};

// main.ts
var import_obsidian2 = __toModule(require("obsidian"));
var CountType;
(function(CountType2) {
  CountType2["Word"] = "word";
  CountType2["Page"] = "page";
  CountType2["Character"] = "character";
  CountType2["Created"] = "created";
  CountType2["Modified"] = "modified";
})(CountType || (CountType = {}));
var countTypes = [
  CountType.Word,
  CountType.Page,
  CountType.Character,
  CountType.Created,
  CountType.Modified
];
var AlignmentType;
(function(AlignmentType2) {
  AlignmentType2["Inline"] = "inline";
  AlignmentType2["Right"] = "right";
  AlignmentType2["Below"] = "below";
})(AlignmentType || (AlignmentType = {}));
var alignmentTypes = [
  AlignmentType.Inline,
  AlignmentType.Right,
  AlignmentType.Below
];
var DEFAULT_SETTINGS = {
  countType: CountType.Word,
  abbreviateDescriptions: false,
  alignment: AlignmentType.Inline,
  debugMode: false
};
var NovelWordCountPlugin = class extends import_obsidian2.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.debugHelper = new DebugHelper();
    this.fileHelper = new FileHelper(this.app.vault);
  }
  get settings() {
    return this.savedData.settings;
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.fileHelper.setDebugMode(this.savedData.settings.debugMode);
      this.debugHelper.setDebugMode(this.savedData.settings.debugMode);
      this.debugHelper.debug("onload lifecycle hook");
      this.addSettingTab(new NovelWordCountSettingTab(this.app, this));
      this.addCommand({
        id: "recount-vault",
        name: "Reanalyze (recount) all documents in vault",
        callback: () => __async(this, null, function* () {
          this.debugHelper.debug("[Reanalyze] command triggered");
          yield this.initialize();
        })
      });
      this.addCommand({
        id: "cycle-count-type",
        name: "Change data type to display",
        callback: () => __async(this, null, function* () {
          this.debugHelper.debug("[Change data type] command triggered");
          this.settings.countType = countTypes[(countTypes.indexOf(this.settings.countType) + 1) % countTypes.length];
          yield this.saveSettings();
          this.updateDisplayedCounts();
        })
      });
      this.handleEvents();
      this.initialize();
    });
  }
  onunload() {
    return __async(this, null, function* () {
      this.saveSettings();
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.savedData = Object.assign({}, yield this.loadData());
      this.savedData.settings = Object.assign({}, DEFAULT_SETTINGS, this.savedData.settings);
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.savedData);
    });
  }
  initialize(refreshAllCounts = true) {
    return __async(this, null, function* () {
      this.debugHelper.debug("initialize");
      if (refreshAllCounts) {
        yield this.refreshAllCounts();
      }
      try {
        yield this.updateDisplayedCounts();
      } catch (err) {
        setTimeout(() => {
          this.initialize(false);
        }, 1e3);
      }
    });
  }
  updateDisplayedCounts(file = null) {
    return __async(this, null, function* () {
      const debugEnd = this.debugHelper.debugStart("updateDisplayedCounts");
      if (!Object.keys(this.savedData.cachedCounts).length) {
        this.debugHelper.debug("No cached data found; refreshing all counts.");
        yield this.refreshAllCounts();
      }
      const fileExplorerLeaf = yield this.getFileExplorerLeaf();
      this.setContainerClass(fileExplorerLeaf);
      const fileItems = fileExplorerLeaf.view.fileItems;
      if (file) {
        const relevantItems = Object.keys(fileItems).filter((path) => file.path.includes(path));
        this.debugHelper.debug("Setting display counts for", relevantItems.length, "fileItems matching path", file.path);
      } else {
        this.debugHelper.debug(`Setting display counts for ${Object.keys(fileItems).length} fileItems`);
      }
      for (const path in fileItems) {
        if (file && !file.path.includes(path)) {
          continue;
        }
        const counts = this.fileHelper.getCountDataForPath(this.savedData.cachedCounts, path);
        const item = fileItems[path];
        item.titleEl.setAttribute("data-novel-word-count-plugin", this.getNodeLabel(counts));
      }
      debugEnd();
    });
  }
  getFileExplorerLeaf() {
    return __async(this, null, function* () {
      return new Promise((resolve, reject) => {
        let foundLeaf = null;
        this.app.workspace.iterateAllLeaves((leaf) => {
          if (foundLeaf) {
            return;
          }
          const view = leaf.view;
          if (!view || !view.fileItems) {
            return;
          }
          foundLeaf = leaf;
          resolve(foundLeaf);
        });
        if (!foundLeaf) {
          reject(Error("Could not find file explorer leaf."));
        }
      });
    });
  }
  getNodeLabel(counts) {
    if (!counts || typeof counts.wordCount !== "number") {
      return "";
    }
    switch (this.settings.countType) {
      case CountType.Word:
        return this.settings.abbreviateDescriptions ? `${counts.wordCount.toLocaleString()}w` : `${counts.wordCount.toLocaleString()} word${counts.wordCount === 1 ? "" : "s"}`;
      case CountType.Page:
        return this.settings.abbreviateDescriptions ? `${counts.pageCount.toLocaleString()}p` : `${counts.pageCount.toLocaleString()} page${counts.pageCount === 1 ? "" : "s"}`;
      case CountType.Character:
        return this.settings.abbreviateDescriptions ? `${counts.characterCount.toLocaleString()}ch` : `${counts.characterCount.toLocaleString()} character${counts.characterCount === 1 ? "" : "s"}`;
      case CountType.Created:
        if (counts.createdDate === 0) {
          return "";
        }
        return this.settings.abbreviateDescriptions ? `${new Date(counts.createdDate).toLocaleDateString()}/c` : `Created ${new Date(counts.createdDate).toLocaleDateString()}`;
      case CountType.Modified:
        if (counts.modifiedDate === 0) {
          return "";
        }
        return this.settings.abbreviateDescriptions ? `${new Date(counts.modifiedDate).toLocaleDateString()}/u` : `Updated ${new Date(counts.modifiedDate).toLocaleDateString()}`;
    }
    return "";
  }
  handleEvents() {
    this.registerEvent(this.app.vault.on("modify", (file) => __async(this, null, function* () {
      this.debugHelper.debug("[modify] vault hook fired, recounting file", file.path);
      yield this.fileHelper.updateFileCounts(file, this.savedData.cachedCounts);
      yield this.updateDisplayedCounts(file);
    })));
    function recalculateAll(hookName, file) {
      return __async(this, null, function* () {
        this.debugHelper.debug(`[${hookName}] vault hook fired by file`, file.path, "recounting all files");
        yield this.refreshAllCounts();
        yield this.updateDisplayedCounts();
      });
    }
    this.registerEvent(this.app.vault.on("rename", (0, import_obsidian2.debounce)(recalculateAll.bind(this, "rename"), 1e3)));
    this.registerEvent(this.app.vault.on("create", (0, import_obsidian2.debounce)(recalculateAll.bind(this, "create"), 1e3)));
    this.registerEvent(this.app.vault.on("delete", (0, import_obsidian2.debounce)(recalculateAll.bind(this, "delete"), 1e3)));
  }
  refreshAllCounts() {
    return __async(this, null, function* () {
      this.debugHelper.debug("refreshAllCounts");
      this.savedData.cachedCounts = yield this.fileHelper.getAllFileCounts();
      yield this.saveSettings();
    });
  }
  setContainerClass(leaf) {
    const container = leaf.view.containerEl;
    const prefix = `novel-word-count--`;
    const alignmentClasses = alignmentTypes.map((at) => prefix + at);
    for (const ac of alignmentClasses) {
      container.toggleClass(ac, false);
    }
    container.toggleClass(prefix + this.settings.alignment, true);
  }
};
var NovelWordCountSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Novel word count settings" });
    new import_obsidian2.Setting(containerEl).setName("Data to show").setDesc("What to show next to each file and folder").addDropdown((drop) => drop.addOption(CountType.Word, "Word Count").addOption(CountType.Page, "Page Count").addOption(CountType.Character, "Character Count").addOption(CountType.Created, "Created Date").addOption(CountType.Modified, "Last Updated Date").setValue(this.plugin.settings.countType).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.countType = value;
      yield this.plugin.saveSettings();
      yield this.plugin.updateDisplayedCounts();
    })));
    new import_obsidian2.Setting(containerEl).setName("Abbreviate descriptions").setDesc("E.g. show '120w' instead of '120 words'").addToggle((toggle) => toggle.setValue(this.plugin.settings.abbreviateDescriptions).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.abbreviateDescriptions = value;
      yield this.plugin.saveSettings();
      yield this.plugin.updateDisplayedCounts();
    })));
    new import_obsidian2.Setting(containerEl).setName("Alignment").setDesc("Show data inline with file/folder names, right-aligned, or underneath").addDropdown((drop) => {
      drop.addOption(AlignmentType.Inline, "Inline").addOption(AlignmentType.Right, "Right-aligned").addOption(AlignmentType.Below, "Below").setValue(this.plugin.settings.alignment).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.alignment = value;
        yield this.plugin.saveSettings();
        yield this.plugin.updateDisplayedCounts();
      }));
    });
    new import_obsidian2.Setting(containerEl).setName("Reanalyze all documents").setDesc("If changes have occurred outside of Obsidian, you may need to trigger a manual analysis").addButton((button) => button.setButtonText("Reanalyze").setCta().onClick(() => __async(this, null, function* () {
      button.disabled = true;
      yield this.plugin.initialize();
      button.setButtonText("Done");
      button.removeCta();
      setTimeout(() => {
        button.setButtonText("Reanalyze");
        button.setCta();
        button.disabled = false;
      }, 1e3);
    })));
    new import_obsidian2.Setting(containerEl).setName("Debug mode").setDesc("Log debugging information to the developer console").addToggle((toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.debugMode = value;
      this.plugin.debugHelper.setDebugMode(value);
      this.plugin.fileHelper.setDebugMode(value);
      yield this.plugin.saveSettings();
    })));
  }
};
